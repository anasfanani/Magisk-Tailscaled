#!/system/bin/sh
set -e
DIR=$(dirname "$(realpath "$0")")
# shellcheck source=../settings.sh
. "$DIR"/../settings.sh
scripts_name=$(basename "$0")

program(){

  # logdir
  # command
  # pre_up
  # pre_down
  # post_up
  # post_down

  # log Debug "logdir ${logdir}"
  # log Debug "command ${command}"
  # log Debug "pre_up ${pre_up}"
  # log Debug "pre_down ${pre_down}"
  # log Debug "post_up ${post_up}"
  # log Debug "post_down ${post_down}"

  program_name=$(echo "$command" | awk '{print $1}' | xargs basename)
  log_file="${logdir}/${program_name}.log"
  pid_file="${logdir}/${program_name}.pid"
  is_running(){
    if PID=$(busybox pgrep -f "${command}"); then
      log Info "✔ ${program_name} service is running with PID: ${PID}."
      return 0
    fi
    return 1
  }
  start(){
    log Info "Starting ${program_name} service."
    if is_running; then return 0; fi 
    if ! command -v "$program_name" > /dev/null 2>&1; then log Error "program not found: ${program_name}"; return 1; fi
    [ -f "${log_file}" ] && mv "${log_file}" "${log_file}.bak" # log for old output
    if [ ! -z "${pre_up}" ];then $pre_up  2>&1; fi
    # shellcheck disable=SC2086
    nohup $command > "${logdir}/${program_name}.log" 2>&1 &
    PID=$!
    # log Debug "Command: ${command}"
    sleep 3 # waiting for program really started
    PID_INFO=$(ps -p $PID -o pid,stime | grep $PID)
    if [ -n "$PID_INFO" ]; then
      # shellcheck disable=SC2086
      set -- $PID_INFO
      pid=$1
      stime=$2
      log Info "✔ ${program_name} service success running with PID: ${pid}, Start time: $stime."
      echo "$pid" > "${pid_file}"
      if [ ! -z "${post_up}" ];then ${post_up} 2>&1; fi
      return 0
    else
      log Error "No process with PID $PID found."
      return 1
    fi
  }
  stop(){
    log Info "Stopping ${program_name} service."
    if PID=$(busybox pgrep -f "${command}"); then
      if [ ! -z "${pre_down}" ];then $pre_down  2>&1; fi
      # Use `busybox pkill` to kill the binary with signal 15, otherwise use `killall`.
      if busybox pkill -f -15 -e "${command}" >/dev/null 2>&1; then
        : # Do nothing if busybox pkill is successful
      else
        busybox killall "${program_name}" >/dev/null 2>&1 || busybox kill -15 "$PID" >/dev/null 2>&1
      fi
    else
      log Info "✘ ${program_name} service is not running."
      [ -t 1 ] && echo "${white}--------------------------------------------${normal}"
      return 0
    fi
    sleep 3 # wait the binary has stopped properly
    if ! busybox pgrep -f "${command}" >/dev/null 2>&1; then
      log Info "✘ ${program_name} shutting down, service is stopped."
      log Info "✘ ${program_name} disconnected."
      if [ ! -z "${post_down}" ];then $post_down  2>&1; fi
      [ -t 1 ] && echo "${white}--------------------------------------------${normal}"
      return 0
    else
      log Warning "⚠️ ${program_name} Not stopped; may still be shutting down or failed to shut down."
      # try forcing it to shut down.
      log Warning "⚠️ try forcing it to shut down."
      # Use `busybox pkill` to kill the binary with signal 9, otherwise use `killall`.
      if busybox pkill -9 "${command}"; then
        : # Do nothing if busybox pkill is successful
      else
        if command -v killall >/dev/null 2>&1; then
          killall -9 "${program_name}" >/dev/null 2>&1 || true
        else
          pkill -9 "${program_name}" >/dev/null 2>&1 || true
        fi
      fi
      sleep 2
      if ! busybox pgrep -f "${command}" >/dev/null 2>&1; then
        log Info "✔ done, you can sleep peacefully."
        if [ ! -z "${post_down}" ];then post_down  2>&1; fi
        [ -t 1 ] && echo "${white}--------------------------------------------${normal}"
        return 0
      fi
    fi
  }
  restart(){
    log Info "Restarting ${program_name} service."
    program stop 
    sleep 0.5
    program start
  }
  
  $1
}

_tailscaled(){
  logdir="${TS_DIR}/run"
  command="${TS_DAEMON_CMD}"
  tailscaled_up(){
    sed -Ei "s/^description=(\[.*][[:space:]]*)?/description=[ ⏲ $CURRENT_TIME | ✔ tailscaled service is running!!! ] /g" "$MOD_PROP"
  }
  tailscaled_down(){
    sed -Ei "s/^description=(\[.*][[:space:]]*)?/description=[ ⏲ $CURRENT_TIME | ✘ tailscaled shutting down, service is stopped !!! ] /g" "$MOD_PROP"
  }
  pre_up=""
  pre_down=""
  post_up="tailscaled_up"
  post_down="tailscaled_down"
  case "$1" in
    status)
      program is_running
    ;;
    start)
      if ! program is_running && ! program start; then
        log Warning "Got unfriendly response after start tailscaled !"
        return 1
      fi
      return 0
    ;;
    restart)
      log Info "Stopping !"
      _tailscaled stop
      log Info "Stop success !"
      sleep 1
      log Info "Restarting !"
      _tailscaled start
      log Info "Restart success !"
    ;;
    stop)
      if ! program stop; then
        log Error "Got unfriendly response after stop tailscaled !"
        return 1
      fi
    ;;
  esac
}

status_tailscaled(){
  echo "${blue}Service Status Info${normal}"
  if _tailscaled status; then
      echo "${green}running${normal}"
      # set +x
      ts_status=$(tailscale status --json)
      # set -x
      ts_status_backend="$(echo "$ts_status" | jq -r .BackendState)"
      if [ "$ts_status_backend" != "Running" ]; then
        echo "  Backend: $ts_status_backend"
        return 1
      fi
      ipv4=$(echo "$ts_status" | jq -r .TailscaleIPs[0])
      ipv6=$(echo "$ts_status" | jq -r .TailscaleIPs[1])
      printf "  ↳ ipv4  \t\t\t${yellow}%s${normal}\n" "${ipv4}"
      printf "  ↳ ipv6  \t\t\t${yellow}%s${normal}\n" "${ipv6}"
      echo "$ts_status" | jq -r --arg green "$green" --arg red "$red" --arg orange "$orange" --arg yellow "$yellow" --arg normal "$normal" '
        (.Peer | to_entries | map(select(.value.Online == true)) | "  ↳ Online (\($green)\(length)\($normal))"),
        (.Peer | to_entries | map(select(.value.Online == true)) | .[] | "\t  ↳ \($green)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)"),
        (.Peer | to_entries | map(select(.value.Online == false)) | "  ↳ Offline (\($red)\(length)\($normal))"),
        (.Peer | to_entries | map(select(.value.Online == false)) | .[] | "\t  ↳ \($red)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)")
      ' | while IFS= read -r line; do echo "$line"; done
  else
      echo "${red}stopped${normal}"
  fi
}
_log(){
  case "$1" in
    service)
      busybox less -F~ "${TS_RUN_LOG_FILE}"
      ;;
    daemon)
      busybox tail -q -n +1 -F "${TS_LOG_FILE}"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "${yellow}${scripts_name} ${yellow}log ${orange}$1 - ${normal}${red}Error: ${normal}command not found."
        return
      fi
      echo "${yellow}usage${normal}: ${green}${scripts_name}${normal} ${yellow}log${normal} {${orange}service|daemon${normal}}"
      ;;
  esac
  
}
_troubleshoot(){
  echo "${red}Not yet ready!${normal}";
  echo "${orange}Solution: ${yellow}Join telegram group at: [ ${green}https://t.me/systembinsh/158${normal} ${yellow}]${normal}";
}
help(){
    if [ "$1" = "default" ]; then
      expand=false
    elif [ "$1" = "all" ]; then
      expand=true
      all=true
    elif [ -z "$1" ];then
      expand=true
    else
      echo "${yellow}${scripts_name} ${yellow}help ${orange}$1 - ${normal}${red}Error: ${normal}command not found."
      return
    fi
    description() {
      w=0
      printf "%s" "$1" | busybox fold -sw70 | while IFS= read -r line; do
        [ $w = 1 ] && printf "  ${yellow}↨${normal}\t\t  %s\n" "$line"
        [ $w = 0 ] && printf "  ${yellow}↨${normal}\t\t%s\n" "↳ $line"; w=1;
      done
    }
    echo "${green}Tailscaled Service Manager${normal}"
    echo "Manage and customizing how tailscaled runs on your Android."
    echo "${blue}Available Command:${normal}"
    printf "${yellow}%s${normal}       \t• %s\n" "start" "Start tailscaled service" && [ -z "$all" ] || description "Read configuration file in ${TS_DIR}/ and store output log to ${TS_LOG_FILE} then write pid file to ${TS_RUN_DIR}."
    printf "${yellow}%s${normal}       \t• %s\n" "stop" "Stop tailscaled service" && [ -z "$all" ] || description "Kill with signal 15, waiting to process doing self cleanup, if still running, then force kill."
    printf "${yellow}%s${normal}       \t• %s\n" "restart" "Restart tailscaled service" && [ -z "$all" ] || description "Kill, waiting, then start the process again, this command also rename file log to ${TS_LOG_FILE}.bak, always have .bak from last running process."
    printf "${yellow}%s${normal}       \t• %s\n" "status" "Show current process status" && [ -z "$all" ] || description "Retreiving info from daemon, usefull for inspect current running process."
    printf "${yellow}%s${normal}       \t• %s\n" "log" "Logging tools" && [ -z "$all" ] || description "View logs from tailscaled daemon, service."
    if $expand; then
      printf "  ${yellow}↳${normal} ${orange}%s${normal}   \t- %s\n" "daemon" "Tailscaled daemon log."
      printf "  ${yellow}↳${normal} ${orange}%s${normal}   \t- %s\n" "service" "Service operation log."
    fi
}

case "$1" in
  start)
    _tailscaled start
    ;;
  stop)
    _tailscaled stop
    ;;
  restart)
    _tailscaled restart
    ;;
  status)
    status_tailscaled
    ;;
  log)
    _log "$2"
    ;;
  troubleshoot)
    _troubleshoot "$2"
    ;;
  help)
    help "$2" "$3"
    ;;
  *)
    if [ -n "$1" ]; then
      echo "${yellow}${scripts_name} ${orange}$1 ${red}not found${normal}, run ${yellow}${scripts_name} ${orange}help${normal} for all command"
      return
    fi
    help "default"
    ;;
esac